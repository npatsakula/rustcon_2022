## Prelude

Данный доклад не ставит собственной целью посвящение в тонкости написания парсеров, реализаций сколь-нибудь сложных систем типов или JIT компиляторов,
но в конце этого доклада наметятся реперные точки в экосистеме языка, которые позволят, не приближаясь к Азатоту, погрузиться в каждое из этих направлений
самостоятельно. Также я хотел бы внимательно остановиться на имеющихся ограничениях экосистемы, как относительно других языков, так и относительно
идеала.

Начать хотелось бы с того, что же такое парсинг и что нам, разработчикам, хотелось бы от средств его осуществляющего. Парсинг -- процесс
преобразования исходного набора символов (может быть как UTF-8 символами, так и битами) сначала в лексемы, а потом и в структуры, которыми 
будет оперировать логика программы [1]. От инструментов же мы хотим три вещи:

1. Гарантии корректности: если речь идёт про свободные от контекста грамматики, мы хотим, чтобы лексемы и структуры разбирались однозначным
   образом и не хотим давать эти гарантии методом внимательного взгляда.
2. Эргономика: помимо соображений эстетики, не хотелось бы увеличивать сложность там, где можно было бы этого избежать.
3. Производительность: для части применений (такими я занимаюсь в своей каждодневной работе) объём разбираемых данных может быть огромным и
   даже парсинг может стать узким местом. Потому хотелось бы взять инструмент, который обеспечивает максимальную производительность при
   соблюдении первых двух пунктов.

Ниже хотелось бы дать обзорную таблицу библиотек парсинга, которые получили широкое распространение. Я проставлю каждой библиотеке оценку по
каждому из интересующих меня параметру от одного до пяти. Я сознательно не добавляю малоизвестные решения вроде `plex` и `reformation` либо
в силу ограниченности применений, либо в силу низкой распространённости (что повышает шансы нарваться на баг или смерть инфраструктуры).

|                    | NOM                                    | Combine                                   | Chumsky | pest | peg | LALRPOP |
|--------------------|----------------------------------------|-------------------------------------------|---------|------|-----|---------|
| Гарантии           | 0 (LL(1))                              | 0 (LL(1))                                 |         |      |     | 5       |
| Эргономика         | 1 (макросы умерли, трейты не родились) | 4 (рекурсивные правила определять больно) |         |      |     | 4       |
| Производительность | 5                                      | 5 (с версии 3 аналогична nom)             |         | 2    | 2   | 4       |

[1] Alexis King. Parse, Don't validate: [оригинал](https://lexi-lambda.github.io/blog/2019/11/05/parse-don-t-validate/), [перевод](https://habr.com/ru/post/498042/).

## Pirouette

В качестве парсер-генератора мы возьмём LALRPOP; для описания грамматики он использует свой язык, основы которого я приведу ниже.

```rust
// Мы можем импортировать структуры, определённые в нашем
// (или чьём-то ещё) крейте:
use crate::Name;

// Здесь мы можем (но пока не будем) указывать контекст
// парсинга и времена жизни.
grammar;

// Здесь мы непосредственно определяем парсер.
//
// Expression -- название парсера, в нативном коде можно
// будет вызвать как `ExpressionParser::new()`.
//
// Name -- тип значения, которое мы пытаемся разобрать.
pub(crate) Expression: Name = {
    "(" <r"\p{alpha}+"> ")" => Name::new(<>),
/*  \1/ \------2------/ \3/    \-----4-----/

    1. Открывающая скобка.
    2. Имя.
      1) Угловые скобки нужны для того, чтобы захватить часть выражения.
      2) `r` сигнализирует о том, что мы хотим использовать регулярные выражения.
    3. Закрывающая скобка.
    4. Сборка структуры `Name`.
      1) Угловые скобки используются для того, чтобы подставить безымянное
         выражение 2.1 в вызов `new`. Если бы безымянных выражений было несколько,
         они бы подставились через запятую. */

    "[" <r"\p{alpha}+"> "]" =>? {
        // `=>?` говорит нам о том, что попытка собрать
        // `Name` может окончится ошибкой.
        let result = Name::try_new(<>)?,
        // Я не хочу руками конвертировать тип ошибки,
        // потому воспользуемся встроенным в Rust механизмом.
        Ok(result)
    },
}
```
